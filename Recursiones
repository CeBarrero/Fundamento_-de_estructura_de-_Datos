import java.io.*;

/**
 * Este código se trata de saber como se manejan las recursiones en la programación para 
 * resolver problemas
 * @author Cesar Barrero
 */

public class Recursiones 
{
	/**
	 * La función consiste en hallar el máximo común divisor entre dos números 
	 * @param a
	 * @param b
	 * @return Se retorna un entrero es el más grande en que se pueden dividor los dos
	 */
	public static int mcd_euclides(int a, int b)
	{
		if (b == 0) 
			return a;
		else
			return mcd_euclides(b, a % b);
	}
	
	
	/**
	 * La función consiste en multiplicar una serie de números que descienden contando al 1
	 * @param x
	 * @return Se retorna el valor de la multiplicación de los números que lo descienden 
	 */
	public static int factorial(int x) //Recursión para hallar factorial
	{
		if (x == 1) 
			return 1;
		else
			return x * factorial(x - 1);
	}
	
	
	/**
	 * La función consiste en la suma de los dos anteriores comenzando con 0 y 1
	 * @param x
	 * @return Se retorna el valor de las sumas, ya sean x veces, como se prefiera 
	 */
	public static int fibonacci(int x) //Recursión para la sucesión fibonacci
	{
		if (x == 0) 
			return 0;
		else
			if(x == 1)
				return 1;
			else
				return fibonacci(x - 1) + fibonacci(x - 2);
	}
	
	
	/**
	 * La función genera un triángulo de números entreros, infinito y simetrico, se empieza 
	 * en 1 y sus bordes están en 1
	 * @param n
	 * @param k
	 * @return Se retorna un triángulo, del cual lo de adentro es la suma de los que tiene
	 * encima 
	 */
	public static int pascal(int n, int k) //Recursión para el triángulo de pascal
	{
		if (k == 0 || k == n)
			return 1;
		else 
			return pascal(n - 1, k - 1) + pascal(n - 1, k);
	}
	
	
	/**
	 * La función imprime el triángulo de pascal
	 * @return Se retornan números enteros formando el triángulo de pascal
	 */
	public static String print_pascal()
	{
		String pascal_matrix = "";
		
		for (int i = 0; i < 10; i++) 
		{
			for (int j = 0; j <= i; j++) 
				pascal_matrix += pascal(i, j) + "\t";
			pascal_matrix += "\n";
		}
		return pascal_matrix;
	}
	
	
	/**
	 * La función consiste en sumar un número tantas veces como lo diga el otro número 
	 * @param n
	 * @param x
	 * @return Se retorna el valor total de la suma 
	 */
	public static int multiplicacion(int n, int x) //Recursión para multiplicar
	{
		if (x == 1) 
			return n;
		else 
			return n + multiplicacion(n, x - 1); 
	}
	
	
	/**
	 * La función consiste en ingresar una cadena y luego invertirla 
	 * @param cadena
	 * @return Se retorna la cadena que se ingreso al revés
	 */
	public static String inversa_cadena(String cadena)
	{
		if (cadena.length() == 1) 
		{
			return cadena;
		}
		else
		{
			return inversa_cadena(cadena.substring(1)) + cadena.charAt(0);
		}
	}
	
	
	public static void main(String[] args) 
	{
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		
		try 
		{
			bw.write(Recursiones.factorial(15) + "\n");
			bw.flush();
			
			bw.write(Recursiones.fibonacci(25) + "\n");
			bw.flush();
			
			bw.write(Recursiones.multiplicacion(654, 97) + "\n");
			bw.flush();
			
			bw.write(Recursiones.mcd_euclides(369, 1218) + "\n");
			bw.flush();
			
			bw.write(Recursiones.inversa_cadena("asdfghjkl") + "\n");
			bw.flush();
			
			bw.write(Recursiones.print_pascal() + "\n");
			bw.flush();
		}
		catch(Exception ex)
		{
			ex.printStackTrace();
		}
	}
}
